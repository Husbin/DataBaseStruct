# DataStructure
数据结构各种基本实现。

----------线性结构-----------------</br>
线性：</br>
连续存储：数组</br>
优点：存取速度快，元素能通过下标快速定位，而链表不行。</br>
缺点：插入/删除操作速度很慢，空间通常是有限制的，事先必须知道数组的长度，需要大块 连续的内存。</br>
</br>
离散存储：链表</br>
优点：空间没有限制，插入/删除元素速度很快。</br>
缺点：存取的速度很慢</br>
1、定义：</br>
n个节点离散分配；</br>
每个节点只有一个前驱结点，每个节点只有一个后续节点；</br>
首节点没有前驱结点，尾节点没有后续节点；</br>
</br>
2、专业术语：</br>
头节点：第一个有效节点之前的节点，方便对链表进行操作，并不存放有效数据，头节点的数据类型与首节点一致；</br>
首节点（首元节点）：第一个有效节点；</br>
尾节点：最后一个有效节点；</br>
头指针：指向头节点的指针变量；</br>
尾指针：指向尾节点的指针变量。</br>
</br>
3、如果希望通过一个函数来对链表进行处理，我们至少需要接受链表那些信息：</br>
只需要一个参数：头指针，通过头指针可以推算出链表的其他所有信息。</br>
</br>
4、分类：单链表；双链表：每个节点有2个指针域；循环链表：能通过任何一个节点找到所有节点。</br>
</br>
5、算法：遍历、查找、清空、销毁、求长度、排序、删除节点、插入节点。</br>
</br>
（要点，先临时定义一个指向p后面节点的指针r）</br>
（在p后面插入节点q）</br>
r = p->pNext; p->pNext = q;(p指向q) q->qNext = r;(q指向下一个节点)</br>
q->pNext = p->pNext;	p->pNext = q;</br>
</br>
（删除p后面的节点）</br>
r = p->pNext; </br>
p->pNext = p->pNext->pNext;</br>
free(r);</br>
</br>
6、算法：</br>
狭义的算法是与数据的存储方式密切相关的。</br>
广义的算法是与数据的存储方式无关的。</br>
泛型：利用某种技术达到的效果就是：不用的存储方式，执行的操作是一样的。</br>
</br>
</br></br>
静态内存（局部变量）在栈分配，栈内存是操作系统分配的。栈区：压栈出栈分配。</br>
动态在堆。堆内存是程序员分配的。堆区：堆排序的方式分配。</br>
线性结构的应用--栈</br>
定义：一种可以实现先进后出的存取结构。类似于箱子，往箱子里面放书，后放的在顶部，可以先拿出来。</br>
分类：</br>
静态栈：以数组为内核</br>
动态栈：以链表为内核</br>
应用：函数调用，中断，表达式求值，内存分配，缓冲处理，走迷宫</br>
</br>
线性结构的应用--队列</br>
定义：一种可以实现先进先出的存储结构。</br>
分类：链式队列：用链表实现</br>
   静态队列：用数组实现（循环队列）</br>
</br>
循环队列：</br>
1、静态队列为什么必须是循环队列：队列的结构是先进先出的，循环队列可对内存重复使用，减少对内存的浪费。</br>
2、循环队列需要几个参数来确定：2个参数：front和rear</br>
3、循环队列各个参数的含义</br>
这两个参数在不同场合有不同的含义：</br>
1）、队列的初始化：front和rear的值都是零</br>
2）、队列非空：front代表第一个元素，rear代表最后一个有效元素的下一个元素。</br>
3）、队列为空：front和rear相等但不一定为零。</br>
4、循环队列入队的伪算法：两步完成</br>
1）、将值存入r所代表的位置</br>
2）、错误写法：rear = rear + 1; 正确写法：rear = (rear + 1)%数组的长度</br>
5、循环队列出队的伪算法：front = (front + 1)%数组长度</br>
6、如何判断循环队列是否为空：如果rear和front相等，则队列为空。</br>
7、如何判断循环队列是否已满：（当front==rear时，无法判断队列为空或满）</br>
1）只用n-1个元素，队列满时rear与front紧挨着（哪个在左边的判断）</br>
2）使用一个变量标识参数，统计元素个数</br>
循环队列中，front与rear的大小关系没有规律，初始化队列时，front与rear的值都为零，但随着队列的不断插入与删除，front与rear的大小关系不确定。最初元素入队阶段，rear的值增加，rear的值比front大，但随着队列元素的处队，以及新元素入队进入循环队列，会出现front的值比rear大的情况。</br>
经常使用的是第一种方法，判断结果如下：</br>
if((rear + 1) % 数组长度 == f){队列已满}</br>
else{队列未满}</br>
队列的具体运用：所有与时间有关的场合都有队列的影子。</br>
</br>
</br>
</br>
1、顺序表。</br>
2、单链表。</br>
3、循环链表。（与单链表（p!=null）相比，循环链表的遍历结束条件为p！=pHead||p->pNext!=pHead）</br> 
4、双向链表。</br> 
5、顺序栈。</br>
//----------------顺序栈的存储结构----------------</br>
typedef struct Stack {</br>
	SElemType *base;		//栈底指针</br>
	SElemType *top;		//栈顶指针</br>
	int stacksize;			//栈可容纳的最大容量</br>
}SQ_STACK;</br>

base为栈底指针，初始化完成后，栈底指针base始终指向栈底的位置，若base的值为NULL，则表面栈结构不存在。top为栈顶指针，其初始值指向栈底。每当插入新的栈顶元素时，指针top增加1，删除栈顶元素时，指针top减少1.因此，栈空时，top和base的值相等，都指向栈底，栈非空时，top始终指向栈顶元素的上一个位置。</br>
